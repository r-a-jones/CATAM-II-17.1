\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{pifont}
\usepackage[table]{xcolor}
\usepackage{centernot}
\usepackage{mathtools}
\usepackage{tabularx}
\usepackage{imakeidx}
\usepackage{booktabs}
\usepackage{pgfplots}
\usepackage{pgfplotstable}
\usepackage{adjustbox}
\usepackage{tkz-euclide}
\usepackage{dashbox}
\usepackage{listings}
\usepackage{verbatim}
\usepackage{tcolorbox}
\usepackage{enumerate}
\usepackage{pmboxdraw}
\usepackage{graphicx}
\usepackage{adjustbox}
\usepackage{caption}
\usepackage{wrapfig}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{scrextend}
\usepackage{float}
\usepackage{caption}
\usepackage{makecell}
\usepackage{footnote}
\usepackage{enumitem}
\usepackage{amsthm}
\usepackage{filecontents}
\usepackage{graphicx,nicefrac}

\pgfplotstableset{
	color cells/.style={
		col sep=comma,
		string type,
		postproc cell content/.code={%
			\pgfkeysalso{@cell content=\rule{0cm}{2.4ex}\cellcolor{black!##1}\pgfmathtruncatemacro\number{##1}\ifnum\number>50\color{white}\fi##1}%
		},
		columns/x/.style={
			column name={},
			postproc cell content/.code={}
		}
	}
}

\makesavenoteenv{tabular}
\newfloat{Algorithm}{htbp}{loa}

\newcommand{\cmark}{\checkmark}%

\newcommand{\xmark}{\ding{55}}%

\newcommand{\legendre}[2]{\left( \frac{#1}{#2} \right)}

\lstset{
	basicstyle=\small\ttfamily,
	columns=flexible,
	breaklines=true
}
\usepackage[a4paper, total={6in, 9in}]{geometry}

\setlength{\parindent}{0pt}

\title{17.1 Graph Colouring}
\date{Easter 2024}
\setlength{\parskip}{0.25em}

\setcounter{secnumdepth}{0}

%\newcommand{\projectquote}[1]{\noindent {\fbox{\begin{minipage}{45em}
				%#1
				%\end{minipage}}}
				%\vspace{3mm}
				%}
			\newcommand{\projectquote}[1]{\noindent {\fbox{\begin{minipage}{45em}
							#1
				\end{minipage}}}
				\vspace{3mm}
			}
			
			\newcommand{\algorithmquote}[1]{\noindent
				{\fbox{\begin{minipage}{44em}
							#1
				\end{minipage}}}
			}
			
			\newcommand{\programquote}[1]{\fontfamily{pcr}\selectfont 
				#1\normalfont
			}
			
			\newcommand{\namepageref}[1]{``\nameref{#1}'' (p. \pageref{#1})}
			
			
			
			
			\definecolor{dkgreen}{rgb}{0,0.6,0}
			\definecolor{gray}{rgb}{0.5,0.5,0.5}
			\definecolor{mauve}{rgb}{0.58,0,0.82}
			
			\begin{document}
				
				\maketitle
				\tableofcontents
				

\newtheorem{lemma}{Lemma}


\newcommand\bsfrac[2]{%
	\scalebox{-1}[1]{\nicefrac{\scalebox{-1}[1]{$#1$}}{\scalebox{-1}[1]{$#2$}}}%
}


\section{17.1 Graph Colouring}
This project's code has been written in C\#. The code can be found in the appendix at \namepageref{appendix_a_code}. The output can be found in \namepageref{appendix_b_output}.

Throughout this project the notation $K_n$ will be used to refer to a complete graph on $n$ vertices.

The \emph{clique number} of a graph $G$ is the largest $n$ such that there exists a $K_{n} \subseteq G$.
		
\subsection{Question 1}

The output can be found at \namepageref{output_question_1} in the appendix.
				
The methods (i)-(iv) as discussed in the project instructions have been implemented, as well as the greedy algorithm. The following tables show the number of colours used by the greedy algorithm for each randomly generated graph in the $\mathcal{G}(70,0.5)$ and $\mathcal{G}_3(70,0.5)$ cases respectively.

\begin{center}
	\pgfplotstabletypeset[
	columns={graphNum, ascending, descending, subgraphs, random},
	columns/graphNum/.style={column name={Graph tested}, string type},
	columns/ascending/.style={column name={Method (i)}, precision=5},
	columns/descending/.style={column name={Method (ii)}, precision=5},
	columns/subgraphs/.style={column name={Method (iii)}, precision=5},
	columns/random/.style={column name={Method (iv)}, precision=5},
	every column/.style={column type/.add={|}{}},
	every last column/.style={column type/.add={}{|}},
	every head row/.style={before row=\hline, after 	row=\hline},
	every last row/.style={after row=\hline},
	]{Program Output/Question1_Table_05.txt}
	\captionof{table}{Number of colours used to colour ten randomly generated graphs in $\mathcal{G}(70,0.5)$.}
\end{center}

\begin{center}
	\pgfplotstabletypeset[
	columns={graphNum, ascending, descending, subgraphs, random},
	columns/graphNum/.style={column name={Graph tested}, string type},
	columns/ascending/.style={column name={Method (i)}, precision=5},
	columns/descending/.style={column name={Method (ii)}, precision=5},
	columns/subgraphs/.style={column name={Method (iii)}, precision=5},
	columns/random/.style={column name={Method (iv)}, precision=5},
	every column/.style={column type/.add={|}{}},
	every last column/.style={column type/.add={}{|}},
	every head row/.style={before row=\hline, after 	row=\hline},
	every last row/.style={after row=\hline},
	]{Program Output/Question1_Table_075.txt}
	\captionof{table}{Number of colours used to colour ten randomly generated graphs in $\mathcal{G}_3(70,0.75)$.}
\end{center}

All the details of the generated graphs (i.e. the precise structure of them) can be found in the program output in the appendix.


As can be seen in both cases, each of the four methods for labelling the vertices are about as equally effective as each other when using the greedy algorithm. % In particular, methods (i), (ii) and (iv) produce incredibly similar averages in both cases, with (iii) slightly worse in the first case, and slightly better in the second case in our given sample. (Taking a larger sample suggests this is an outlier and that the four methods are indeed about the same on average.)

Graphs randomly selected from $\mathcal{G}_3(70,0.75)$ notably require much fewer colours on average than those in $\mathcal{G}(70,0.5)$ via the greedy algorithm. This is notable, as the expected number of edges of a graph in $\mathcal{G}(70,0.5)$ is

$$\binom{70}{2} \cdot 0.5 = 1207.5,$$

which is lower than the expected number of edges of a graph in $\mathcal{G}_3(70,0.75)$ which is

$$\left(\binom{70}{2} - \underbrace{\binom{24}{2} - 2 \cdot \binom{23}{2}}_{(\ast)}\right) \cdot 0.75 = 1224.75,$$

[$(\ast)$ accounts for the pairs of vertices $i,j$ with $i-j \equiv 0 \mod 3$, which shouldn't be counted.]

despite the much higher average number of colours used in the case of $\mathcal{G}(70,0.5)$.

This result does however make sense when we note that the rule that no edge $ij$ can exist with $i-j \equiv 0 \mod 3$ gives rise to a lot of structure within a graph randomly chosen from $\mathcal{G}_3(70,0.75)$, allowing a colouring with few colours to arise more easily, whereas a graph randomly chosen from $\mathcal{G}(70,0.5)$ is expected to have no such structure, meaning little symmetry can be exploited by a colouring to allow for a small number of colours to exist.


%As can be seen in both cases, method (iii), that is, the ordering where $v_j$ has minimum degree in the graph $G - \{v_{j+1}, . . . , v_n\}$, is much more effective than the other three methods, which are more-or-less equally as effective as each other in each case.

%We may explain why (iii) is more effective in the second case by noting that its method of ordering the vertices compliments how the greedy algorithm functions. Since the greedy algorithm will tend to colour a vertex with a larger number in cases where the vertex has a large number of neighbours proceeding it in the ordering, this method of labelling the vertices in such a way as to minimise the number of neighbours with an earlier position in the ordering will reduce the likelihood of such a case occurring. 


\subsection{Question 2}

\subsubsection{An ordering guaranteeing that the greedy algorithm uses no more than 3 colours for $\mathcal{G}_3(70, 0.75)$}

An order guaranteeing such a result can be obtained as follows:

Suppose $v_1, \dots, v_{70}$ is the original labelling of the graph's vertices after generating it from $\mathcal{G}_3(70, 0.75)$. In particular, this labelling obeys the rule that $v_i v_j$ is not an edge when $i - j \equiv 0 \mod 3$.

We construct a new labelling $v'_1, \dots, v'_{70}$ as follows, where the square brackets denote ordered sets:

$$[v'_1, \dots, v'_{70}] = [v_1, v_4, v_7, \dots, v_{67}, v_{70} v_2, v_5, v_8, \dots, v_{68}, v_3, v_6, v_9, \dots, v_{69}].$$

That is, we group the original $v_i$s by congruency class: require all $v_i$ with $i \equiv 1 \mod 3$ to come first, followed by the $v_i$ with $i \equiv 2 \mod 3$, then the $v_i$ with $i \equiv 0 \mod 3$.

Such an ordering guarantees that the vertices that were originally $v_i$ with $i \equiv 1 \mod 3$ will be labelled with the colour $1$, due to no edges existing between these vertices. The $i \equiv 2 \mod 3$ will then be labelled with at most the colour $2$ similarly (some may be coloured with $1$) and the final congruence class labelled with at most the colour $3$.

This idea can be easily extended to give an ordering that guarantees a graph selected from $\mathcal{G}_k(n, p)$ will be coloured in no more than $k$ colours.


\subsubsection{Why was $p=0.75$ chosen here?}

As per our discussion in question 1, we note that $$\mathbb{E}(\text{\#edges of $G$ chosen from $\mathcal{G}(70, 0.5)$}) \approx \mathbb{E}(\text{\#edges of $G$ chosen from $\mathcal{G}_3(70, p)$})$$ when $p=0.75$. Despite the similar number of edges, in question 1 we remarked that the greedy algorithm is able to find a much better colouring $\mathcal{G}_3(70, 0.75)$ due to the structure that arises in such graphs. In this question we proved that such a graph can indeed by coloured by greedy in at most $3$ colours by exploiting this structure.

No such structure can be exploited for a graph $G$ chosen in $\mathcal{G}(70, 0.5)$, meaning we are unable to do similar analysis to give an upper bound on $\chi(G)$, let alone provide an ordering such that the greedy algorithm constructs it. Indeed, it is hypothetically possible we pick $G = K_{70}$, the complete graph on $70$ vertices, requiring $70$ colours.

\subsubsection{A graph $G$ of order $3n$ such that $\chi(G) = 3$ but on which greedy might need $n + 2$ colours}

Consider the graph $G$ as defined. $G$ has vertices labelled $\{ v_{i,j} \mid 1 \leq i \leq 3, 1 \leq j \leq n\}$, in particular $3n$ vertices. Say $v_{i,j}$ is connected to $v_{i',j'}$ provided either:

\begin{itemize}
	\item $i \neq i'$ and $j \neq j'$,
	\item $j = j' = n$.
\end{itemize}

The following demonstrates a $3$-colouring of $G$:

Let $A_i = \{v_{i, j} \mid 1 \leq j \leq n \}$ for $i = 1, 2, 3$. Then colour all the vertices in the set $A_i$ with the colour $i$, $i=1,2,3$. This is a $3$-colouring.

The greedy algorithm produces an $n+2$-colouring if we order the vertices as $v'_1, \dots, v'_{3n}$ as follows:

$$[v'_1, \dots, v'_{3n}] = [v_{1,1}, v_{2,1}, v_{3,1}, v_{1,2}, v_{2,2}, v_{3,2}, \dots v_{1,n}, v_{2,n}, v_{3,n}].$$

Under this ordering: $v_{1,1}, v_{2,1}, v_{3,1}$ are not connected to each other, so they all get coloured $1$. $v_{1,2}, v_{2,2}, v_{3,2}$ are all not connected to each other, but are connected to two of $v_{1,1}, v_{2,1}, v_{3,1}$, thus get coloured $2$. $v_{1,3}, v_{2,3}, v_{3,3}$ are not connected to each other but are connected to two of those vertices we coloured $1$ and two of those vertices we coloured $2$. Thus they get coloured $3$. In general $v_{1,j}, v_{2,j}, v_{3,j}$ get coloured $j$ for $j<n$. Then $v_{1,n}, v_{2,n}, v_{3,n}$ form a triangle, with each connected to something of colour $1, 2, \dots, n-1$, thus they get coloured $n, n+1, n+2$ respectively.

A similar construction can be used to find a graph $G$ of order $kn$ such that $\chi(G) = k$, but which greedy uses $n+k-1$ colours.

\subsection{Question 3}

\subsubsection{An argument to suggest that it is unlikely the greedy-type algorithm will find a complete subgraph of order $14$ in a graph from $\mathcal{G}(2000, 0.5)$.}

First, note that the probability that any given $14$ randomly selected vertices selected from such a graph forms a $K_{14}$ is $\left( \frac{1}{2} \right)^{\binom{14}{2}} \approx 4.04 \cdot 10^{-28}$.

The way this greedy algorithm works, given a sequence $v_1, \dots, v_{14}$ of vertices in the graph, we first check if $v_2$ is connected to $v_1$, requiring $1$ operation to test, with a probability of succeeding being $\frac{1}{2}$. If we fail, we terminate this process. We then check if $v_3$ is connected to $v_1$ and $v_2$, requiring $2$ operation to test, with a probability of succeeding being $\frac{1}{4}$, if we fail we terminate, and so on.

On average, the number of operations that this algorithm uses per set of input vertices $v_1, \dots, v_{14}$ is

$$\begin{aligned}
	\mathbb{E}(\text{operations}) &= 1 + \frac{1}{2}(2 + \frac{1}{4}(3 + \cdots)) \\
	&= 1 + \frac{1}{2} \cdot 2 + \frac{1}{2^3} \cdot 3 + \dots + \frac{1}{2^{\binom{14}{2}}} \cdot 14 \\
	&\approx 2.44.
\end{aligned}$$

but, with a success chance of $\left( \frac{1}{2} \right)^{\binom{14}{2}}$.

Thus, if we were to pick $14$-tuples of vertices at random from the graph until we successfully found a $K_{14}$, it will take about $2^{\binom{14}{2}} \cdot 2.44 \approx 6.05 \cdot 10^{27}$ operations to do so, i.e. the program will not terminate in a reasonable amount of time.

We can optimise this algorithm somewhat by noting that if we have already found, say, a $K_{13}$ within the vertices $v_1, \dots, v_{13}$, it is worth testing all tuples $(v_1, \dots, v_{13}, v)$ for $v$ a vertex in the graph distinct from $v_1, \dots, v_{13}$ for a $K_{14}$. Similarly, if we have found a  $K_{12}$ we try using it to construct a $K_{13}$, and so on (i.e. the algorithm traverses a tree-like structure representing all possible pairs, triplets, ..., $14$-tuples of vertices of the graph, in a depth-first manner.) This optimisation will however still result in an incredibly large number of operations before a $K_{14}$ is likely to be found, due to the sheer size of the graph, and the exponentials involved in the probabilities we may increase our clique size at any given stage of the algorithm.

Note that while it is incredibly \emph{unlikely} that such an algorithm will find a $K_{14}$ in a graph randomly chosen from $\mathcal{G}(2000, 0.5)$, it is incredibly \emph{likely} that such a graph contains a $K_{14}$. As we argue in the next part of this question, the clique number of such a graph is almost surely between 16 and 18, 

\subsubsection{How large do you think a clique is likely to be in a graph from $\mathcal{G}(2000, 0.5)$?}



The following is a theorem proven in II Graph Theory\footnote{The lecturer for this year, 2023-4, provides it in his notes as "Theorem 5" of "Chapter 6: Random Graphs", located on page 39 (page 41 in the linked PDF document). A sketch proof is also provided there. See \url{https://tartarus.org/gareth/maths/notes/ii/Graph_Theory.pdf}.}, which we can apply to this question:

\emph{Theorem.} Let $G$ be chosen from $\mathcal{G}(n,p)$. Let $d \in \mathbb{R}_{>0}$ be the positive number such that $\binom{n}{d} p^{\binom{d}{2}} = 1$ (where we extend the binomial coefficient $\binom{\ast}{\ast}$ to the real numbers via the gamma function.) Then, almost surely, $G$ has clique number equal to $\lceil d \rceil$, $\lfloor d \rfloor$ or $\lfloor d \rfloor - 1$.

Applying this theorem, for $n=2000$, $p=0.5$, we find $d \approx 17.2$. Thus, almost surely, $G$ has its largest clique of size $16, 17$ or $ 18$. As remarked in the previous section of this question, this means that almost surely there is a $K_{14} \subseteq G$, despite the fact that the greedy-like algorithm is incredibly unlikely to find a $K_{14}$.

\subsection{Question 4}

The output can be found at \namepageref{output_question_4} in the appendix.

\subsubsection{How the clique-finding algorithm works}

Say the graph $G$ has $n$ vertices, ordered as $v_1, \dots, v_n$. We find all the complete subgraphs of the graph $G$ recursively. Call $\mathcal{K}_i$ the set of all $i$-tuples of vertices of $G$ that form a $K_i$.

\begin{itemize}
	\item $\mathcal{K}_1$ is just the set of all vertex singletons in $G$. We initialise it in the program by just looping through $j=1, \dots, n$ and adding $\{ v_j\}$ to it.
	
	\item From $\mathcal{K}_i$ we can deduce $\mathcal{K}_{i+1}$:
	
	\subitem For each $K \in \mathcal{K}_i$:
	
	\subsubitem Let $m$ be the maximal $l$ such that $v_l \in K$ (e.g $m=4$ for $K = \{v_1, v_3, v_4\}$). For each $j = m+1, \dots, n$, test to see if $K \cup \{ v_j\}$ is a complete subgraph (by testing if $v_l v_j$ is an edge for all $v_l \in K$). If so, add $K \cup \{ v_j\}$ to $\mathcal{K}_{i+1}$.
	
	\subitem Is $\mathcal{K}_{i+1}$ empty? If so, $i$ is the clique number of $G$, and the elements of $\mathcal{K}_{i}$ are the cliques. Return this result.
	
	\subitem If not, then increment $i$.
	
	\subsubitem This process will surely terminate because we will find $\mathcal{K}_{n+1} = \emptyset$ (no complete subgraph with $n+1$ vertices exists because only $n$ vertices exist.)
\end{itemize}

The use of $m$ as defined "Let $m$ be the maximal $l$ such that..." in the program ensures efficiency and a lack of duplicate cliques: if, say, $\{ v_1, v_2, v_3\}$ were a clique, we would find that clique via $\{ v_1, v_2\}$ in the previous step which was in turn found via $\{ v_1\}$, but it would not be found from any other $I \subsetneq \{ v_1, v_2, v_3\}$ as a previous step.

\subsubsection{A human-verifiable example of the clique algorithm working}

I have generated a graph with $10$ vertices in order to test this clique-finding algorithm. The output here is more human-friendly and can be verified much faster, the program claims to find two distinct cliques of size 5 in this graph, it can be verified that this is indeed the case:

\begin{tcolorbox}[size=small]
	\begin{verbatim}
		Finding the cliques for the following graph:
		VertexOrderedGraph(10, (1, 2) (1, 3) (1, 4) (1, 5) (1, 6) (2, 3) (2, 4) (2, 5)
		(2, 6) (2, 7) (2, 8) (2, 9) (3, 4) (3, 7) (3, 8) (4, 5) (4, 6) (4, 8) (4, 9)
		(5, 6) (5, 8) (5, 10) (6, 8) (6, 9) (7, 8) (7, 9) (7, 10) (9, 10))
		It has clique number 5
		Clique(s) found:
		[1, 2, 4, 5, 6]
		[2, 4, 5, 6, 8]
	\end{verbatim}
\end{tcolorbox}

The line beginning \programquote{VertexOrderedGraph} tells us the information specifiying the graph - the initial \programquote{10} tells us it is a graph on $10$ vertices, and each \programquote{(x,y)} specifies that $xy$ is an edge of the graph. It is possible to check manually that the two cliques listed are in fact complete subgraphs of the graph, and no $K_6$ appears in this graph.

\subsubsection{Compare, for several graphs, the resulting lower bound you get on $\chi(G)$ with the upper bounds obtained previously.}

As before, we generate $10$ random graphs from $\mathcal{G}(70, 0.5)$ and $\mathcal{G}_3(70, 0.75)$ each. (Note different graphs as in question 1 have been generated.)

The greedy algorithm values for the orderings (i)-(iv) have been calculated as in question 1. Their minimum has been provided, giving an upper bound on $\chi(G)$. The clique numbers have been calculated giving a lower bound on $\chi(G)$.

The following values were found:

\begin{center}
	\pgfplotstabletypeset[
	columns={num, upperBound, lowerBound},
	columns/num/.style={column name={Graph tested}, string type},
	columns/upperBound/.style={column name={Upper bound}, precision=5},
	columns/lowerBound/.style={column name={Lower bound}, precision=5},
	every column/.style={column type/.add={|}{}},
	every last column/.style={column type/.add={}{|}},
	every head row/.style={before row=\hline, after 	row=\hline},
	every last row/.style={after row=\hline},
	]{Program Output/Question4_Table_05.txt}
	\captionof{table}{Upper and lower bounds on the chromatic number calculated by the question 1 \& clique algorithms for ten graphs in $\mathcal{G}(70,0.5)$.}
\end{center}

\begin{center}
	\pgfplotstabletypeset[
	columns={num, upperBound, lowerBound},
	columns/num/.style={column name={Graph tested}, string type},
	columns/upperBound/.style={column name={Upper bound}, precision=5},
	columns/lowerBound/.style={column name={Lower bound}, precision=5},
	every column/.style={column type/.add={|}{}},
	every last column/.style={column type/.add={}{|}},
	every head row/.style={before row=\hline, after 	row=\hline},
	every last row/.style={after row=\hline},
	]{Program Output/Question4_Table_075.txt}
	\captionof{table}{Upper and lower bounds on the chromatic number calculated by the question 1 \& clique algorithms for ten graphs in $\mathcal{G}_3(70,0.75)$.}
\end{center}

As before, all the details of the generated graphs can be found in the program output in the appendix.

As can be seen in the case of the graphs in $\mathcal{G}_3(70,0.75)$, the program was able to specify the chromatic number in nine of ten cases, as the upper bound is equal to the lower bound. Note that as per our analysis in question 2, we know $3$ is an upper bound for the chromatic number of any element of $\mathcal{G}_3(70,0.75)$, thus we can determine outside the program that all ten of the generated graphs have $\chi(G) = 3$.

Indeed, an element of $\mathcal{G}_3(70,0.75)$ is incredibly likely to have a chromatic number of exactly $3$ - we have proven $3$ is an upper bound, for $1$ to occur we must have precisely zero edges generate (there are $1633$ possible edges, thus the probability this occurs is $0.25^{1633}$, essentially zero) or no triangles generate (a more long-winded combinatorial argument can also show this probability is negligible).

Recall the theorem stated in question 3 regarding what the clique number of $G \in \mathcal{G}(n,p)$ almost surely is. For $n=70$, $p=0.5$, we can compute that this theorem tells us the clique number is almost surely $7, 8$ or $9$ (we get $d \approx 8.99$) which indeed matches our results in that table.

\subsection{Question 5}

The output can be found at \namepageref{output_question_5} in the appendix.

\subsubsection{Calculating a maximal independent set via the clique algorithm}

For a graph $G$, say $G^c$ is the graph on the same vertex set as $G$ but with $ij$ an edge of $G \iff ij$ not an edge of $G^c$.

It follows that any complete subgraph of $G^c$ corresponds to an independent set of $G$, and thus that a clique of $G^c$ corresponds to a maximal independent subset of $G$.

Thus, we run the clique algorithm on $G^c$ to calculate such a set.


\emph{Remark.} Our procedure as implemented in my code chooses for $I_i$ at each stage the first clique found in $G - I_1 - \dots - I_{i-1}$ where the cliques are ordered as the vertices are ordered and lexicographically. For example, if our two cliques are $C_1 = [3,5,7,10]$, $C_2 = [3,5,8,9]$, we say $C_1 < C_2$ as the first index in which $C_1$ and $C_2$ differ, $C_1$ has the lower number. It may be possible that in some graphs, choosing different cliques at each stage may result in a differently sized partition of $G$ into sets. We do not check all possible cliques like this, but if one were interested in an algorithm giving an improved lower bound, albeit with more computations required, implementing this is a possibility.

\subsubsection{A human-verifiable example of the clique algorithm working}

As before, here is a human readable example of the program working, running on $10$ vertices:

\begin{tcolorbox}[size=small]
	\begin{verbatim}
		Question 5
		Finding I1, I2, I3, ... for the following graph:
		VertexOrderedGraph(10, (1, 3) (1, 4) (1, 5) (1, 6) (1, 9) (1, 10) (2, 4) (2, 8)
		(2, 9) (2, 10) (3, 4) (3, 7) (3, 10) (4, 7) (4, 8) (5, 6) (5, 8) (5, 9) (6, 7)
		(6, 9) (7, 8) (8, 10))
		Found:
		I_1 = [1, 2, 7]
		I_2 = [3, 6, 8]
		I_3 = [4, 5, 10]
		I_4 = [9]
	\end{verbatim}
\end{tcolorbox}

It is possible to verify that:

\begin{itemize}
	\item $I_1, I_2, I_3, I_4$ partition the graph into a valid colouring
	\item $I_1$ is a clique in the original graph $G$, indeed it is the first clique in lexicographic order, $I_2$ is the first clique in lexicographic order of $G-I_1$, etc.
 \end{itemize}
 
 i.e. the program is working correctly.
 
 \subsubsection{Comparison of upper bound to results from previous questions}
 
 The following two tables provide ten examples of the algorithm working on $\mathcal{G}(70, 0.5)$ and $\mathcal{G}_7(70, 0.5)$ each. I have had to omit tests on $\mathcal{G}_3(70, 0.75)$ for this algorithm due to the program being unable to complete them in a reasonable time. Recall, however, that the question $1$ methods to calculate an upper bound for such graphs were very effective in that case, so this is not much of a disappointment.
 
 \begin{center}
 	\pgfplotstabletypeset[
 	columns={num, oldUpperBound, newUpperBound, lowerBound},
 	columns/num/.style={column name={Graph tested}, string type},
 	columns/oldUpperBound/.style={column name={Upper bound (Q1 algorithm)}, precision=5},
 	columns/newUpperBound/.style={column name={Upper bound (Q5 algorithm)}, precision=5},
 	columns/lowerBound/.style={column name={Lower bound}, precision=5},
 	every column/.style={column type/.add={|}{}},
 	every last column/.style={column type/.add={}{|}},
 	every head row/.style={before row=\hline, after 	row=\hline},
 	every last row/.style={after row=\hline},
 	]{Program Output/Question5_Table_G.txt}
 	\captionof{table}{Upper and lower bounds on the chromatic number calculated by the question 1, question 5 \& clique algorithms for ten graphs in $\mathcal{G}(70,0.5)$.}
 \end{center}
 
  \begin{center}
 	\pgfplotstabletypeset[
 	columns={num, oldUpperBound, newUpperBound, lowerBound},
 	columns/num/.style={column name={Graph tested}, string type},
 	columns/oldUpperBound/.style={column name={Upper bound (Q1 algorithm)}, precision=5},
 	columns/newUpperBound/.style={column name={Upper bound (Q5 algorithm)}, precision=5},
 	columns/lowerBound/.style={column name={Lower bound}, precision=5},
 	every column/.style={column type/.add={|}{}},
 	every last column/.style={column type/.add={}{|}},
 	every head row/.style={before row=\hline, after 	row=\hline},
 	every last row/.style={after row=\hline},
 	]{Program Output/Question5_Table_G7.txt}
 	\captionof{table}{Upper and lower bounds on the chromatic number calculated by the question 1, question 5 \& clique algorithms for ten graphs in $\mathcal{G}_7(70,0.5)$.}
 \end{center}
 
 As can be seen in both tables, in both cases, question 5's algorithm did better on all samples than the question 1 algorithm.
 
 We may be interested in the value of $\mathbb{E}(\text{number of colours used in Q1}) - \mathbb{E}(\text{number of colours used in Q5})$, i.e. the average number of colours question 5's algorithm saves.
 
The first table gives the estimate that, for $\mathcal{G}(70,0.5)$, this statistic is $1.8$, and the second table gives, for $\mathcal{G}_7(70,0.5)$, the estimate is $4.7$.

Recall from question 2 that it is possible to colour $\mathcal{G}_k(n,p)$ in no more than $k$ colours. The program exploits how we proved this in the $\mathcal{G}_7(70,0.5)$ case, as it is likely that a maximal independent set in the graph corresponds to vertices whose labels are all in the same congruence class $\mod 7$ on most steps of the algorithm. There is room for error here as the algorithm is not guaranteed to do this, hence why we get a bound of $8$ or $9$ in most cases. It is however notable that our results so far were able to classify $\chi(G)$ in $3$ of $10$ cases, and lower the possible range significantly in the others.

\subsubsection{Varying $p$}

For $n=70$ vertices, I ran $5$ tests in each of $p=0.4,0.41,\dots, 0.6$ for both $\mathcal{G} := \mathcal{G}(70,p)$ and $\mathcal{G}_7 := \mathcal{G}_7(70,p)$, finding the average upper bound for both the question 1 and question 5 tests, and the difference between them.

\begin{center}
	\pgfplotstabletypeset[
	columns={p, GoldUpperBound, GnewUpperBound, dGBound, G7oldUpperBound, G7newUpperBound, dG7bound},
	columns/p/.style={column name={$p$}, string type},
	columns/GoldUpperBound/.style={column name={$\mathcal{G}$ avg. (Q1)}, precision=5},
	columns/GnewUpperBound/.style={column name={$\mathcal{G}$ avg. (Q5)}, precision=5},
	columns/dGBound/.style={column name={$\mathcal{G}$ (Q1-Q5)}, precision=5},
	columns/G7oldUpperBound/.style={column name={$\mathcal{G}_7$ avg. (Q1)}, precision=5},
	columns/G7newUpperBound/.style={column name={$\mathcal{G}_7$ avg. (Q5)}, precision=5},
	columns/dG7bound/.style={column name={$\mathcal{G}_7$ (Q1-Q5)}, precision=5},
	every column/.style={column type/.add={|}{}},
	every last column/.style={column type/.add={}{|}},
	every head row/.style={before row=\hline, after 	row=\hline},
	every last row/.style={after row=\hline},
	]{Program Output/Question5_varyingp_70.txt}
	\captionof{table}{Average upper bounds for 5 samples in $\mathcal{G} := \mathcal{G}(70,p)$ and $\mathcal{G}_7 := \mathcal{G}_7(70,p)$ for varying $p$}
\end{center}

In $\mathcal{G}(70,p)$, we can see that the average upper bound on the chromatic number increases for both the question 1 and question 5 algorithm as $p$ increases, which is understandable as the larger number of edges will result in a larger number of colours required. A trend in the difference between the question 1 and question 5 algorithms does not appear to be visible. There is a very slight positive correlation, that is larger $p$ results in a larger difference (Pearson's correlation coefficient is about $0.37$). I have repeated this test for other $n$ as can be seen in the next section, and those results suggest no correlation, so this is likely an outlier. That is, the number of colours that the question 5 algorithm saves over the question 1 algorithm is essentially constant with respect to $p$.

In $\mathcal{G}_7(70,p)$, there is a clear trend: the question 5 algorithm gets much better for larger $p$, resulting in an increasing difference between the algorithms. This makes sense when we consider our reasoning above and in question 2; an optimal colouring of a graph in $\mathcal{G}_7(70,p)$ is where the vertices are coloured with respect to their congruence class $\mod 7$. As remarked in this question, it is likely that the maximal independent sets found correspond to a congruence class, although it is possible a different clique in the graph's compliment is picked. However, as $p$ increases, the chance such a clique forms decreases (as fewer edges exist in the complement), and at $p=1$ the only maximal independent sets that can be picked are the congruence classes. This proves that the expected value of the number of colours used in the question 5 algorithm for a $\mathcal{G}_7(70,p)$ graph tends to $7$ as $p \to 1$, which indeed matches what we find in the table.

\begin{center}
	\begin{tikzpicture}
		\begin{axis}[samples=100,axis lines=middle,
			xlabel=$p$,
			ylabel={Average difference in \#colours used in Q1 vs Q5 algorithms},
			xmin=0.38,
			xmax=0.6,
			xtick={0.4,0.45,...,0.6},
			ymin=0,
			ymax=2.5,
			ytick={0,0.2,...,2.5},
			width=6in,
			height=6cm,
			axis x discontinuity=crunch,
			]
			\addplot[only marks, mark=*, color=blue] table [x=p,y=dGBound] {Program Output/Question5_varyingp_70.txt};
			
		\end{axis}
	\end{tikzpicture}
	\captionof{figure}{The average differences between the number of coloured used in the question 1 algorithm vs the question 5 algorithm for graphs in $\mathcal{G}(70,p)$.}
\end{center}

\begin{center}
	\begin{tikzpicture}
		\begin{axis}[samples=100,axis lines=middle,
			xlabel=$p$,
			ylabel={Average difference in \#colours used in Q1 vs Q5 algorithms},
			xmin=0.38,
			xmax=0.6,
			xtick={0.4,0.45,...,0.6},
			ymin=0,
			ymax=7.5,
			ytick={0,0.5,...,7.5},
			width=6in,
			height=6cm,
			axis x discontinuity=crunch,
			]
			\addplot[only marks, mark=*, color=blue] table [x=p,y=dG7bound] {Program Output/Question5_varyingp_70.txt};
			
		\end{axis}
	\end{tikzpicture}
	\captionof{figure}{The average differences between the number of coloured used in the question 1 algorithm vs the question 5 algorithm for graphs in $\mathcal{G}_7(70,p)$.}
\end{center}

\newpage

\subsubsection{Varying $n$ and $p$}

The amount of time my program takes to compute these results increases rapidly as $n$ increases. So, I have investigated for $30 \leq n \leq 70$.

I have constructed tables such as the one above for $n=30,35,40,\dots,70$ which can be found in the output in the appendix. We investigate the trends here for the question 5 algorithm.



%\pgfplotstabletypeset[color cells]
%\\
\begin{center}
	\pgfplotstabletypeset[
	columns/p/.style={column name={$\bsfrac{n}{p}$}, precision=5},
	every first column/.style={column type/.add={}{|}},
	every head row/.style={after 	row=\hline}]{Program Output/Question5_G_heatmap.txt}
	
	\captionof{table}{Average number of colours used for the question $5$ algorithm on $\mathcal{G}(n,p)$, 5 samples used for each cell.}
\end{center}

As can be seen, the average number of colours used increases as either $n$ or $p$ increases, which is to be expected as per our previous explanations.

It appears, that for each fixed $n$, the expected number of colours increases linearly with $p$ (it can be checked that for each fixed $n$, the correlation coefficient is $>0.85$, with most very close to $1$). Also, for fixed $p$, the expected number of colours increases linearly with $n$ (it can be checked that for each fixed $p$, the correlation coefficient is $>0.9$, with most very close to $1$).

Thus, it seems reasonable to conjecture that $$\mathbb{E}(\text{\#colours the question 5 algorithm takes to colour a graph in $\mathcal{G}(n,p)$}) \propto np \quad \forall n \forall p.$$

\begin{center}
	\pgfplotstabletypeset[
	columns/p/.style={column name={$\bsfrac{n}{p}$}, precision=5},
	every first column/.style={column type/.add={}{|}},
	every head row/.style={after 	row=\hline}]{Program Output/Question5_G7_heatmap.txt}
	
	\captionof{table}{Average number of colours used for the question $5$ algorithm on $\mathcal{G}_7(n,p)$, 5 samples used for each cell.}
\end{center}

The trends for $\mathcal{G}_7(n,p)$ appear much less clear, with the expected value appearing to increase as $p$ increases for small $n$, and decrease as $p$ increases for large $n$, within the table. As per our reasoning earlier, we know that as $p \to 1$, the expected value tends to $7$, and this is independent of $n$, so the increasing trends cannot continue.

What appears to be the case is that for a given $n$ there is some $p_n$ that is least optimal, that is, the question 5 algorithm takes the most colours on average for $p \approx p_n$, being more efficient for $p < p_n$, and $p > p_n$.

For example, with $n=45$, we appear to see the maximum within the table, it seems the number of colours used peaks somewhere around $0.55$, that is, $p_{45} \approx 0.55$.

This trend can be explained by the fact that there is a trade-off:

\begin{itemize}
	\item For $p$ small, few edges exist in the average graph picked from $\mathbb{G}(n,p)$, thus any maximal independent sets picked for $I_1, I_2, \dots$ are likely to be efficient.
	\item For $p$ large, as discussed, we are more likely to be forced into picking $I_1, I_2, \dots$ corresponding to the congruence classes $\mod 7$ of the vertices' labels, thus forcing us into what is almost surely a minimal colouring.
	\item For $n$ small, we are less likely to exhaust as many colours due to their being fewer vertices to colour, so the positives of $p$ being small as described here is more likely to be pronounced. This explains why these values peak for larger $p$ in the table.
	\item For $n$ large, we are likely to exhaust more colours, so the positives of large $p$ locking us into the specific colouring corresponding to congruence classes is more likely to be effective. This explains why these values peak for earlier $p$ in the table.
\end{itemize}

For fixed $p$, the expected value seems to vary linearly with $n$, in particular for $p$ not close to $0.5$. The correlation coefficient for such $p$ is high.

\newpage

\subsection{Question 6}

The output can be found at \namepageref{output_question_6} in the appendix.

\subsubsection{The theoretical running times of the algorithms above when the input is a typical member of $\mathcal{G}(n,0.5)$}



To estimate the theoretical running times, we generate samples and analyse the trends.

\emph{Colouring via the greedy algorithm (question 1)} I wrote code for this part of the question to find the average running time for $30$ samples of random graphs in $\mathcal{G}(n,0.5)$ for each of $n=20,25,\dots,100$. Each of the samples were ordered in the four different ways as specified in question 1, and tested for each of those.

\begin{center}
 	\pgfplotstabletypeset[
 	columns/n/.style={column name={$n$}, precision=5},
 	columns/averageSecondsToComputeAsc/.style={column name={avg. seconds (i)}, string type},
 	columns/averageSecondsToComputeDsc/.style={column name={avg. seconds (ii)}, string type},
 	columns/averageSecondsToComputeMinimalAmong/.style={column name={avg. seconds (iii)}, string type},
 	columns/averageSecondsToComputeRandom/.style={column name={avg. seconds (iv)}, string type},
 	every column/.style={column type/.add={|}{}},
 	every last column/.style={column type/.add={}{|}},
 	every head row/.style={before row=\hline, after 	row=\hline},
 	every last row/.style={after row=\hline}]{Program Output/Question6_q1_table.txt}
 	
 	\captionof{table}{The average time in seconds to colour a graph from $\mathcal{G}(n,0.5)$ via the greedy algorithm, for each of the ordering methods. Each $n$ has had $30$ samples of graphs in the computation.}
\end{center}

After experimenting with various trendlines, we find that quadratic regression fits the data above very well - for each method, the parabola of best fit has an $R^2$ value of $0.9933, 0.9895, 0.9876, 0.9899$ respectively. Thus, it seems that the running time is $O(n^2)$.

We can explain this $O(n^2)$ running time via analysing the algorithm: when colouring vertex $i$, we have to check whether it is connected to vertex $1,2,\dots,i-1$, and if it is, what colour that vertex is. So, in total, we have to check $1+2+3+\dots+n-1$ vertices. This is $\binom{n}{2}$, a quadratic in $n$.

Notably, each method colours the graph in about the same time on average as each other method for fixed $n$, suggesting no method above is better or worse than any other method.


\emph{Finding a clique (question 4)} I wrote code for this part of the question to find the average running time for $30$ samples of random graphs in $\mathcal{G}(n,0.5)$ for each of $n=30,35,\dots,70$.

\begin{center}
 	\pgfplotstabletypeset[
 	columns={n, averageSecondsToCompute},
 	columns/n/.style={column name={$n$}, precision=5},
 	columns/averageSecondsToCompute/.style={column name={average no. seconds to compute}, precision=6},
 	every column/.style={column type/.add={|}{}},
 	every last column/.style={column type/.add={}{|}},
 	every head row/.style={before row=\hline, after 	row=\hline},
 	every last row/.style={after row=\hline}]{Program Output/Question6_clique_table.txt}
 	
 	\captionof{table}{The average time in seconds to find the cliques in a graph from $\mathcal{G}(n,0.5)$. Each $n$ has had $30$ samples of graphs in the computation.}
\end{center}

We see an exponential trend: by performing linear regression on $n$ versus $\ln(\text{average no. seconds to compute})$ and performing linear regression, we obtain a line of best fit\footnote{$\ln(\text{average no. seconds to compute}) = 0.1307n - 9.2895$} with a very strong $R^2$ value of $0.9925$.

\begin{center}
	\begin{tikzpicture}
		\begin{axis}[samples=100,axis lines=middle,
			xlabel=$n$,
			ylabel={$\ln(\text{average no. seconds to compute})$},
			xmin=27,
			xmax=70,
			ymin=-6,
			ymax=2,
			width=6in,
			height=6cm,
			axis x discontinuity=crunch,
			]
			\addplot[only marks, mark=*, color=blue] table [x=n,y=lnaverageSecondsToCompute] {Program Output/Question6_clique_table.txt};
			\addplot [ domain=27:70, samples=30, color=red]
			{0.1307*x - 9.2895};
			
		\end{axis}
	\end{tikzpicture}
	\captionof{figure}{$n$ versus $\ln(\text{average no. seconds to compute})$ plotted. The line of best fit is shown in red.}
\end{center}

Thus, it appears that the clique-finding algorithm is $O(e^n)$.

$\emph{Finding maximal independent sets $I_1, I_2, \dots$ (question 5)}$ Once again, $30$ samples for $n=30,35,\dots,70$ each.

\begin{center}
	\pgfplotstabletypeset[
	columns={n, averageSecondsToCompute},
	columns/n/.style={column name={$n$}, precision=5},
	columns/averageSecondsToCompute/.style={column name={average no. seconds to compute}, precision=6},
	every column/.style={column type/.add={|}{}},
	every last column/.style={column type/.add={}{|}},
	every head row/.style={before row=\hline, after 	row=\hline},
	every last row/.style={after row=\hline}]{Program Output/Question6_q5_table.txt}
	
	\captionof{table}{The average time in seconds to colour a graph from $\mathcal{G}(n,0.5)$ via the question 5 method. Each $n$ has had $30$ samples of graphs in the computation.}
\end{center}

Again, we see an exponential trend by performing linear regression. The line of best fit\footnote{$\ln(\text{average no. seconds to compute}) = 0.1434n-9.7139$} has a very strong $R^2$ value of $0.9948$.

\begin{center}
	\begin{tikzpicture}
		\begin{axis}[samples=100,axis lines=middle,
			xlabel=$n$,
			ylabel={$\ln(\text{average no. seconds to compute})$},
			xmin=27,
			xmax=70,
			ymin=-6,
			ymax=2,
			width=6in,
			height=6cm,
			axis x discontinuity=crunch,
			]
			\addplot[only marks, mark=*, color=blue] table [x=n,y=lnaverageSecondsToCompute] {Program Output/Question6_q5_table.txt};
			\addplot [ domain=27:70, samples=30, color=red]
			{0.1434*x-9.7139};
			
		\end{axis}
	\end{tikzpicture}
	\captionof{figure}{$n$ versus $\ln(\text{average no. seconds to compute})$ plotted. The line of best fit is shown in red.}
\end{center}

Thus it appears that this algorithm is $O(e^n)$ also. This makes sense since it incorporates question 4's clique algorithm which is also $O(e^n)$. The only other algorithm used here is the algorithm to find the complement of a graph, which is $O(n^2)$ due to having to loop through all $\binom{n}{2}$ edges, which is a quadratic in $n$, which $e^n$ beats.

\subsubsection{A procedure for colouring a graph with exactly $\chi(G)$ colours}

This first procedure is very inefficient and can certainly be improved upon - we outline a second procedure which is better. We will analyse its running time after describing it.

Say \programquote{n} is the number of vertices of the graph $G$ we wish to find a $\chi(G)$-colouring of. Let \programquote{chi = 1}. Let \programquote{foundValidColouring = false}.

While \programquote{foundValidColouring} is \programquote{false}:
\begin{itemize}
	\item Construct all \programquote{chi\string^n} possible combinations of colourings of $G$ in \programquote{chi} colours. (Note these may not be valid colourings, i.e. two neighbouring vertices may have the same colour.)
	\item Check if any of them are a valid colouring.
	\subitem If we find a valid colouring, set \programquote{foundValidColouring} to \programquote{true}. The value that \programquote{chi} currently is, is $\chi(G)$.
	\subitem If no valid colouring is found, increment \programquote{chi}.
 \end{itemize}
 
Constructing the $\chi^n$ possible colourings on a given loop can be done in $O(\chi^n)$ steps - we may count $1,2,\dots, \chi^n$ to iterate through all the colourings, with the base-$\chi$ digits of the current iteration we are on representing the colours of the $n$ vertices, where the colours are labelled $0,1,\dots,\chi-1$. (Add leading zeroes if necessary.)

Checking if a colouring is a valid colouring can be done in $O(n^2)$ steps: we need to check if each vertex has no colour in common with its neighbours. There are $n$ vertices, for each one we check which of the $n-1$ other vertices neighbour it, and what colours they are if it is a neighbour.

In the worst case, $G$ requires $n$ colours and this is $O(1^n+2^n+\dots+n^n)$.

An improvement: note a colouring of $G$, ($V(G)= \{v_1, \dots, v_n\}$) is also a colouring of each subgraph of $G$. So, if we were to find all valid colourings of $G-\{v_n\}$ in some number of colours $\chi$, we will be able to find a colouring of $G$ in $\chi$ or $\chi+1$ colours. We may recursively construct a colouring of $G-\{v_n\}$ from $G-\{v_{n-1},v_n\}$, and so on. By recursively constructing colourings in this way, we can improve the complexity of the algorithm by only proceeding with the valid colourings at each step, thus reducing the number of computations.

We may also improve our algorithm by using some of the imperfect methods we have investigated in this project. For example, in some of our tests we found an upper bound on $\chi(G)$ equal to a lower bound, with the bounds corresponding to a colouring we have explicitly constructed, hence in those cases we can determine a colouring very quickly. Even if the upper bound and lower bound differ after applying our tests, we may use the reduced search range to decrease the amount of computations we need to do in this brute-force method to find $\chi(G)$.

\newpage
				




\section{Appendix A: Code}
\label{appendix_a_code}

\lstset{frame=tb,
	language=[Sharp]C,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=3
}
				
\subsection{Extensions.cs}

\begin{lstlisting}
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace GraphColouringProject
{
	public static class Extensions
	{
		/// <summary>
		/// Removes all tuples with equal entries from the list. E.g. [(1,1),(1,2),(2,3)] -> [(1,2),(2,3)]
		/// </summary>
		/// <typeparam name="T"></typeparam>
		/// <returns></returns>
		public static (T, T)[] RemoveAllTuplesWithEqualEntries<T>(this (T, T)[] tuples)
		{
			List<(T, T)> newTuples = new List<(T, T)>();
			foreach (var tuple in tuples) {
				if (tuple.Item1.Equals(tuple.Item2) == false)
				{
					newTuples.Add(tuple);
				}
			}
			return newTuples.ToArray();
		}
		/// <summary>
		/// Ordered in ascending order.
		/// </summary>
		/// <param name="tuple"></param>
		/// <returns></returns>
		public static (int, int) Ordered(this (int, int) tuple)
		{
			if (tuple.Item1 >= tuple.Item2)
			{
				return (tuple.Item2, tuple.Item1);
			}
			else
			{
				return tuple;
			}
		}
		
		public static int Mod(this int n, int modulus)
		{
			int newN = n;
			
			while (newN < 0)
			{
				newN += modulus;
			}
			
			return newN % modulus;
		}
		
		public static string ToFormattedString<T>(this T[] arr)
		{
			
			if (arr.Length == 0)
			{
				return "[]";
			}
			
			string result = "[";
			
			foreach (T item in arr)
			{
				result += item;
				result += ", ";
			}
			
			result = result.Substring(0, result.Length - 2);
			result += "]";
			
			return result;
		}
		
		public static List<T> Copy<T>(this List<T> list)
		{
			List<T> newList = new List<T>();
			
			foreach (T item in list)
			{
				newList.Add(item);
			}
			return newList;
		}
		
		public static T[] Copy<T>(this T[] list)
		{
			List<T> newList = new List<T>();
			
			foreach (T item in list)
			{
				newList.Add(item);
			}
			return newList.ToArray();
		}
	}
}

\end{lstlisting}

\subsection{Graph.cs}

\begin{lstlisting}
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using System.Threading.Tasks;

namespace GraphColouringProject
{
	
	
	/// <summary>
	/// A graph whose vertices are given an ordering 1, ..., n.
	/// </summary>
	public class VertexOrderedGraph
	{
		private static Random random = new Random();
		int numberOfVertices;
		
		(int, int)[] edges;
		
		public VertexOrderedGraph(int numberOfVertices, (int, int)[] edges)
		{
			this.numberOfVertices = numberOfVertices;
			this.edges = edges;
			FormatEdges();
		}
		
		public void FormatEdges()
		{
			edges = edges.RemoveAllTuplesWithEqualEntries();
			
			
			edges = edges.Select(x => x.Ordered()).ToArray();
			
			foreach ((int, int) edge in edges)
			{
				if (edge.Item2 > numberOfVertices || edge.Item2 <= 0 || edge.Item1 <= 0)
				{
					throw new Exception("Invalid edge: " + edge.ToString());
				}
			}
		}
		
		public int NumberOfVerticesConnectedTo(int vertex)
		{
			int count = 0;
			foreach ((int, int) edge in edges)
			{
				if (edge.Item1 == vertex || edge.Item2 == vertex)
				{
					count++;
				}
			}
			return count;
		}
		
		public bool AreConnected(int vertexA, int vertexB)
		{
			if (vertexA > vertexB)
			{
				return AreConnected(vertexB, vertexA);
			}
			return edges.Contains((vertexA, vertexB));
		}
		public int NumberOfVerticesConnectedTo(int vertex, int[] ignoring)
		{
			int count = 0;
			foreach ((int, int) edge in edges)
			{
				if (!(ignoring.Contains(edge.Item1) || ignoring.Contains(edge.Item2)))
				{
					if (edge.Item1 == vertex || edge.Item2 == vertex)
					{
						count++;
					}
				}
				
			}
			return count;
		}
		
		/// <summary>
		/// Give the list of all vertices we are connected to with a smaller number. e.g. if 3 is connected to 1,2, 4, returns [1,2]
		/// </summary>
		/// <param name="vertex"></param>
		/// <returns></returns>
		public int[] VerticesConnectedToWithSmallerID(int vertex)
		{
			List<int> result = new List<int>();
			for (int i = 1; i < vertex; i++)
			{
				if (edges.Contains((i, vertex)))
				{
					result.Add(i);
				}
			}
			return result.ToArray();
		}
		
		/// <summary>
		/// Returns a new graph isomorphic to this one, where the vertices are ordered by increasing or descending degree. True if ascending, false if descending
		/// </summary>
		/// <returns></returns>
		private VertexOrderedGraph ReorderByAscendingDescendingDegree(bool ascending)
		{
			//a list containing each vertices ID followed by the number of vertices it is connected to
			List<(int, int)> numberOfConnectedStats = new List<(int, int)>();
			
			for (int i = 1; i <= numberOfVertices; i++)
			{
				numberOfConnectedStats.Add((i, NumberOfVerticesConnectedTo(i)));
			}
			
			if (ascending)
			{
				numberOfConnectedStats = numberOfConnectedStats.OrderBy(x => x.Item2).ToList();
			}
			else
			{
				numberOfConnectedStats = numberOfConnectedStats.OrderBy(x => -x.Item2).ToList();
			}
			
			
			int[] permutationSpecifier = numberOfConnectedStats.Select(x => x.Item1).ToArray();
			
			//permutation specifier tells us how we relabel the vertices. e.g. the slot at index 0 is where 1 is relabelled to and so on, due to array indexing.
			
			//we can now make the new graph
			
			List<(int, int)> newEdges = new List<(int, int)>();
			
			foreach ((int, int) edge in edges)
			{
				newEdges.Add((permutationSpecifier[edge.Item1 - 1], permutationSpecifier[edge.Item2 - 1]));
				
				
			}
			
			return new VertexOrderedGraph(numberOfVertices, newEdges.ToArray());
		}
		
		public VertexOrderedGraph ReorderByAscendingDegree()
		{
			return ReorderByAscendingDescendingDegree(true);
		}
		public VertexOrderedGraph ReorderByDescendingDegree()
		{
			return ReorderByAscendingDescendingDegree(false);
		}
		
		/// <summary>
		/// Reorder as in part iii of question 1
		/// </summary>
		/// <returns></returns>
		public VertexOrderedGraph ReorderByMinimalAmongSubgraphs()
		{
			//specifies that 1 -> permutationSpecifier[0], 2 -> permutationSpecifier[1], etc.
			List<int> permutationSpecifier = new List<int>();
			
			
			while (permutationSpecifier.Count < numberOfVertices)
			{
				int minimalDegreeAmongSubgraphFound = -1;
				int vertexWithMinimalDegree = 0;
				
				for (int i = 1; i <= numberOfVertices; i++)
				{
					if (permutationSpecifier.Contains(i) == false) //not done this one yet
					{
						int degree = NumberOfVerticesConnectedTo(i, permutationSpecifier.ToArray());
						
						if (degree < minimalDegreeAmongSubgraphFound || minimalDegreeAmongSubgraphFound == -1)
						{
							minimalDegreeAmongSubgraphFound = degree;
							vertexWithMinimalDegree = i;
						}
						
					}
				}
				if (minimalDegreeAmongSubgraphFound == -1)
				{
					throw new Exception("Was not able to find vertex with minimal degree");
				}
				
				permutationSpecifier.Add(vertexWithMinimalDegree);
			}
			
			// Console.WriteLine(permutationSpecifier.ToArray().ToFormattedString());
			
			List<(int, int)> newEdges = new List<(int, int)>();
			
			foreach ((int, int) edge in edges)
			{
				newEdges.Add((permutationSpecifier[edge.Item1 - 1], permutationSpecifier[edge.Item2 - 1]));
				
				
			}
			
			return new VertexOrderedGraph(numberOfVertices, newEdges.ToArray());
			
		}
		
		/// <summary>
		/// Reorders the graph randomly.
		/// </summary>
		/// <returns></returns>
		public VertexOrderedGraph ReorderRandomly()
		{
			//essentially, we shall generate a random permutation, and apply that to the vertices' labelling.
			List<int> verticesNotReordered = new List<int> ();
			
			for (int i = 1; i <= numberOfVertices; i++)
			{
				verticesNotReordered.Add(i);
			}
			
			List<int> permutationSpecifier = new List<int>();
			
			while (verticesNotReordered.Count > 0)
			{
				int index = random.Next(0, verticesNotReordered.Count);
				permutationSpecifier.Add(verticesNotReordered[index]);
				verticesNotReordered.RemoveAt(index);
			}
			
			List<(int, int)> newEdges = new List<(int, int)>();
			
			foreach ((int, int) edge in edges)
			{
				newEdges.Add((permutationSpecifier[edge.Item1 - 1], permutationSpecifier[edge.Item2 - 1]));
				
				
			}
			
			return new VertexOrderedGraph(numberOfVertices, newEdges.ToArray());
		}
		
		//choose from G(n, p)
		public static VertexOrderedGraph RandomGraph(int numberOfVertices, double edgeProbabiliy)
		{
			List<(int, int)> edges = new List<(int, int)>();
			for (int i = 1; i < numberOfVertices; i++)
			{
				for (int j = i+1; j <= numberOfVertices; j++)
				{
					double randomInZeroOne = random.NextDouble();
					
					if (randomInZeroOne <= edgeProbabiliy)
					{
						edges.Add((i, j));
					}
				}
			}
			
			return new VertexOrderedGraph(numberOfVertices, edges.ToArray());
		}
		
		//choose from Gk(n, p)
		public static VertexOrderedGraph RandomGraph(int numberOfVertices, double edgeProbabiliy, int differenceModNotAllowed)
		{
			List<(int, int)> edges = new List<(int, int)>();
			for (int i = 1; i < numberOfVertices; i++)
			{
				for (int j = i + 1; j <= numberOfVertices; j++)
				{
					if ((i-j).Mod(differenceModNotAllowed) != 0) //not i-j = 0 mod k
					{
						double randomInZeroOne = random.NextDouble();
						
						if (randomInZeroOne <= edgeProbabiliy)
						{
							edges.Add((i, j));
						}
					}
					
				}
			}
			
			return new VertexOrderedGraph(numberOfVertices, edges.ToArray());
		}
		
		/// <summary>
		/// Color this vertex ordered graph via greedy. Colours are given numbers 1, 2, ...
		/// </summary>
		/// <returns></returns>
		public int[] GreedyColouring()
		{
			int[] colors = new int[numberOfVertices];
			
			
			for (int i = 1; i <= numberOfVertices; i++)
			{
				//find the color of i
				
				
				
				int[] previousNeighbors = VerticesConnectedToWithSmallerID(i);
				
				List<int> neighbourColors = new List<int>();
				
				foreach (int neighbour in previousNeighbors)
				{
					neighbourColors.Add(colors[neighbour - 1]); //-1 due to indexing
				}
				
				int currentColor = 1;
				while (neighbourColors.Contains(currentColor))
				{
					currentColor++;
				}
				colors[i-1] = currentColor; //-1 due to indexing
				
			}
			return colors;
		}
		
		public int GreedyColouringNumberOfColours()
		{
			return GreedyColouring().Max();
		}
		
		public override string ToString()
		{
			string edgesString = "";
			
			foreach (var edge in edges)
			{
				edgesString += edge.ToString();
				edgesString += " ";
			}
			edgesString = edgesString.Trim();
			
			return "VertexOrderedGraph(" + numberOfVertices + ", " + edgesString + ")";
		}
		
		/// <summary>
		/// Find the cliques of this graph. The clique number of the graph is just the length of any element of the returned int[][]
		/// </summary>
		public int[][] FindCliques()
		{
			int i = 1;
			
			//The complete subgraphs of this graph of size i.
			List<int[]> completeSubgraphsOfSizei = new List<int[]>();
			
			//Construct it manually for i = 1. just all the singletons.
			
			for (int j = 1; j <= numberOfVertices; j++)
			{
				completeSubgraphsOfSizei.Add(new int[] { j });
			}
			
			//we use these recursively to construct all the complete subgraphs of size i+1.
			
			List<int[]> completeSubgraphsOfSizeiPlusOne = new List<int[]>();
			do
			{
				//Console.WriteLine(i);
				completeSubgraphsOfSizeiPlusOne = new List<int[]>();
				
				//try construct all the next level subgraphs by recursion
				
				foreach (int[] completeSubgraph in completeSubgraphsOfSizei)
				{
					//we do this max thing so that we dont find things twice. e.g. we will find the complete subgraph 1, 2 starting from the singleton 1, but not from 2.
					int maxOrderedNodeID = completeSubgraph.Max();
					
					
					for (int j = maxOrderedNodeID+1; j <= numberOfVertices; j++)
					{
						//if j is connected to all of the stuff, thats a complete subgraph of size i+1
						bool allAreConnected = true;
						foreach (int originalNode in completeSubgraph)
						{
							if (AreConnected(originalNode, j) == false)
							{
								allAreConnected = false;
								break;
							}
						}
						if (allAreConnected) //new complete subgraph: this + j!
						{
							int[] newCompleteSubgraph = new int[completeSubgraph.Length + 1];
							
							for (int k = 0; k < completeSubgraph.Length; k++)
							{
								newCompleteSubgraph[k] = completeSubgraph[k];
							}
							newCompleteSubgraph[completeSubgraph.Length] = j;
							
							completeSubgraphsOfSizeiPlusOne.Add(newCompleteSubgraph);
						}
					}
				}
				
				
				
				i++;
				if (completeSubgraphsOfSizeiPlusOne.Count > 0) //more stuff to do at the next stage
				{
					completeSubgraphsOfSizei = completeSubgraphsOfSizeiPlusOne.Copy();
				}
				
				
			} while (completeSubgraphsOfSizeiPlusOne.Count > 0); //we have found stuff of size i+1.
			
			
			i -= 1; //i is now the clique number of the graph
			
			return completeSubgraphsOfSizei.ToArray();
			
		}
		
		/// <summary>
		/// Returns the complement of this graph, i.e xy an edge iff xy not an edge in the complement
		/// </summary>
		/// <returns></returns>
		public VertexOrderedGraph Complement()
		{
			List<(int, int)> complementEdges = new List<(int, int)> ();
			for (int i = 1; i < numberOfVertices; i++)
			{
				for (int j = i+1; j <= numberOfVertices; j++)
				{
					if (AreConnected(i,j) == false)
					{
						complementEdges.Add((i, j));
					}
				}
			}
			return new VertexOrderedGraph(numberOfVertices, complementEdges.ToArray());
		}
		
		//Make a new graph, isomorphic to this - (the subgraph verticesToSubtract)
		public VertexOrderedGraph Subtract(int[] verticesToSubtract)
		{
			//verify input
			
			foreach (int vertex in verticesToSubtract)
			{
				if (vertex <= 0 || vertex > numberOfVertices)
				{
					throw new Exception("Invalid vertex.");
				}
			}
			
			
			//first, get the new edges naively.
			
			List<(int, int)> newEdges = new List<(int, int)>();
			
			foreach ((int, int) edge in this.edges)
			{
				if (!(verticesToSubtract.Contains(edge.Item1) || verticesToSubtract.Contains(edge.Item2)))
				{
					//still in the graph
					
					//Console.WriteLine((edge.Item1, edge.Item2) + " still in the graph");
					newEdges.Add((edge.Item1, edge.Item2));
				}
			}
			
			
			//now, relabel stuff where it is not needed, e.g. if we remove just 3, 1->1, 2->2, 4->3, 5->4
			
			int newNumberOfVertices = numberOfVertices - verticesToSubtract.Length;
			
			int newVertex = 1;
			for (int oldVertex = 1; oldVertex <= numberOfVertices; oldVertex++)
			{
				
				
				if (!verticesToSubtract.Contains(oldVertex))
				{
					//oldVertex -> newVertex
					
					//so replace all instances of oldVertex with newVertex
					
					for (int i = 0; i < newEdges.Count; i++)
					{
						//this can be optimised a lot as we know how the edges are ordered in the array
						//but it will have minimal improvement so i dont care
						//it should be done if this program were extended to graphs with larger numbers of vertices
						(int, int) oldNewEdge = newEdges[i];
						
						if (oldNewEdge.Item1 == oldVertex)
						{
							oldNewEdge.Item1 = newVertex;
						}
						if (oldNewEdge.Item2 == oldVertex)
						{
							oldNewEdge.Item2 = newVertex;
						}
						newEdges[i] = oldNewEdge;
					}
					
					
					newVertex++;
				}
			}
			
			return new VertexOrderedGraph(newNumberOfVertices, newEdges.ToArray());
			
			
		}
		
		/// <summary>
		/// Colours the graph by the method as in Q5
		/// returns sets, each of which are a different colour
		/// 
		/// so our colouring uses result.Length colours.
		/// </summary>
		/// <returns></returns>
		public int[][] ColourByQuestion5Method()
		{
			int i = 1;
			VertexOrderedGraph currentGraph = new VertexOrderedGraph(this.numberOfVertices, this.edges); //will be G - I1 - ... - Ii-1 at stage i
			
			List<int[]> Is = new List<int[]>(); //[I1, I2, ...]
			
			List<int> currentRemovedVertices = new List<int>();
			while (currentGraph.numberOfVertices > 0)
			{
				//Console.WriteLine("current graph = " + currentGraph.ToString());
				VertexOrderedGraph currentComplement = currentGraph.Complement();
				
				int[] Ii = currentComplement.FindCliques()[0]; // just take the first clique we find to be Ii i suppose, will be the same size as all other cliques. guaranteed at least 1
				
				//note Ii is labelled as in the subgraph. need to convert it back to our original labelling
				
				//Console.WriteLine(Ii.ToFormattedString());
				//Console.WriteLine(Ii.Max());
				
				int oldMax = Ii.Max();
				int oldVertex = 1;
				
				int[] newIi = Ii.Copy();
				for (int newVertex = 1; newVertex <= Math.Max(numberOfVertices, Ii.Max()); newVertex++)
				{
					while (currentRemovedVertices.Contains(oldVertex))
					{
						//Console.WriteLine(oldVertex);
						oldVertex++;
					}
					
					//newVertex -> oldVertex
					
					for (int j = 0; j < Ii.Length; j++)
					{
						if (Ii[j] == newVertex)
						{
							newIi[j] = oldVertex;
						}
					}
					
					oldVertex++;
				}
				
				currentGraph = currentGraph.Subtract(Ii);
				
				
				Ii = newIi.Copy();
				
				
				Is.Add(Ii);
				
				foreach (int vertex in Ii)
				{
					currentRemovedVertices.Add(vertex);
				}
				
				
				i++;
				
				
			}
			
			return Is.ToArray();
			
		}
		
	}
	
}

\end{lstlisting}

\subsection{Program.cs}

\begin{lstlisting}
// See https://aka.ms/new-console-template for more information
using GraphColouringProject;

Question1(); //Greedy algorithm color tests
Question4(); //Clique algorithm tests
Question5(); //I1, I2, I3... tests
Question6(); //running time tests
void Question1()
{
	
	Console.WriteLine("Question 1");
	int numberOfRandomGraphs = 10;
	
	int verticesInRandomGraphs = 70;
	double probability = 0.5;
	
	
	//Do the G(70, 0.5) ones
	Console.WriteLine("Doing tests for G(70, 0.5)");
	List<VertexOrderedGraph> randomGraphs = new List<VertexOrderedGraph>();
	
	for (int i = 0; i < numberOfRandomGraphs; i++)
	{
		randomGraphs.Add(VertexOrderedGraph.RandomGraph(verticesInRandomGraphs, probability));
	}
	Question1TestsWithGraphs(randomGraphs.ToArray());
	
	Console.WriteLine("Doing tests for G3(70, 0.75)");
	//Do the G3(70, 0.75) ones
	probability = 0.75;
	randomGraphs = new List<VertexOrderedGraph>();
	
	for (int i = 0; i < numberOfRandomGraphs; i++)
	{
		randomGraphs.Add(VertexOrderedGraph.RandomGraph(verticesInRandomGraphs, probability, 3));
	}
	Question1TestsWithGraphs(randomGraphs.ToArray());
	
}

void Question4()
{
	
	
	
	
	
	Console.WriteLine("Question 4");
	
	//Do an example clique test
	
	int verticesInRandomGraphs = 10;
	double probability = 0.5;
	
	VertexOrderedGraph cliqueTestGraph = VertexOrderedGraph.RandomGraph(verticesInRandomGraphs, probability);
	
	Console.WriteLine("Finding the cliques for the following graph:");
	Console.WriteLine(cliqueTestGraph.ToString());
	
	int[][] cliques = cliqueTestGraph.FindCliques();
	
	int cliqueNumber = cliques[0].Length;
	
	Console.WriteLine("It has clique number " + cliqueNumber);
	
	Console.WriteLine("Clique(s) found:");
	
	foreach (int[] clique in cliques)
	{
		Console.WriteLine(clique.ToFormattedString());
	}
	
	
	int numberOfRandomGraphs = 10;
	
	verticesInRandomGraphs = 70;
	
	
	//Do the G(70, 0.5) ones
	Console.WriteLine("Doing tests for G(70, 0.5)");
	List<VertexOrderedGraph> randomGraphs = new List<VertexOrderedGraph>();
	
	for (int i = 0; i < numberOfRandomGraphs; i++)
	{
		randomGraphs.Add(VertexOrderedGraph.RandomGraph(verticesInRandomGraphs, probability));
	}
	Question4TestsWithGraphs(randomGraphs.ToArray());
	
	Console.WriteLine("Doing tests for G3(70, 0.75)");
	//Do the G3(70, 0.75) ones
	probability = 0.75;
	randomGraphs = new List<VertexOrderedGraph>();
	
	for (int i = 0; i < numberOfRandomGraphs; i++)
	{
		randomGraphs.Add(VertexOrderedGraph.RandomGraph(verticesInRandomGraphs, probability, 3));
	}
	Question4TestsWithGraphs(randomGraphs.ToArray());
}

void Question5()

{
	Console.WriteLine("Question 5");
	
	
	//Do an example clique test
	
	int verticesInRandomGraphs = 10;
	double probability = 0.5;
	
	VertexOrderedGraph cliqueTestGraph = VertexOrderedGraph.RandomGraph(verticesInRandomGraphs, probability);
	
	Console.WriteLine("Finding I1, I2, I3, ... for the following graph:");
	Console.WriteLine(cliqueTestGraph.ToString());
	
	int[][] Is = cliqueTestGraph.ColourByQuestion5Method();
	
	
	
	Console.WriteLine("Found:");
	
	for (int i = 1; i <= Is.Length; i++)
	{
		Console.WriteLine("I_" + i + " = " + Is[i - 1].ToFormattedString());
	}
	
	int numberOfRandomGraphs = 10;
	
	verticesInRandomGraphs = 70;
	
	
	//Do the G(70, 0.5) ones
	Console.WriteLine("Doing tests for G(70, 0.5)");
	List<VertexOrderedGraph> randomGraphs = new List<VertexOrderedGraph>();
	
	for (int i = 0; i < numberOfRandomGraphs; i++)
	{
		randomGraphs.Add(VertexOrderedGraph.RandomGraph(verticesInRandomGraphs, probability));
	}
	Question5TestsWithGraphs(randomGraphs.ToArray());
	
	//really slow
	/*
	Console.WriteLine("Doing tests for G3(70, 0.75)");
	//Do the G3(70, 0.75) ones
	probability = 0.75;
	randomGraphs = new List<VertexOrderedGraph>();
	
	for (int i = 0; i < numberOfRandomGraphs; i++)
	{
		randomGraphs.Add(VertexOrderedGraph.RandomGraph(verticesInRandomGraphs, probability, 3));
	}
	Question5TestsWithGraphs(randomGraphs.ToArray());
	*/
	
	
	Console.WriteLine("Doing tests for G3(70, 0.5)");
	//Do the G3(70, 0.5) ones
	probability = 0.5;
	randomGraphs = new List<VertexOrderedGraph>();
	
	for (int i = 0; i < numberOfRandomGraphs; i++)
	{
		randomGraphs.Add(VertexOrderedGraph.RandomGraph(verticesInRandomGraphs, probability, 7));
	}
	Question5TestsWithGraphs(randomGraphs.ToArray());
	
	
	//Lets investigate different p
	
	
	//int numberOfRandomGraphs;
	numberOfRandomGraphs = 5; //it takes long so lets do half as much
	
	//int verticesInRandomGraphs = 70;
	
	for (int numberVertices = 30; numberVertices <= 70; numberVertices += 5)
	{
		Console.WriteLine("For " + numberVertices);
		Question5VaryProbabilityTests(numberOfRandomGraphs, numberVertices);
	}
	
	
	
	
}

void Question6()
{
	int numberOfRandomGraphsPerTest = 30;
	double edgeProbability = 0.5;
	Console.WriteLine("Question 6");
	
	Console.WriteLine("Find greedy algorithm - q1");
	
	Console.WriteLine("n\taverageSecondsToComputeAsc\taverageSecondsToComputeDsc\taverageSecondsToComputeMinimalAmong\taverageSecondsToComputeRandom");
	
	for (int numberOfVertices = 20; numberOfVertices <= 100; numberOfVertices += 5)
	{
		List<VertexOrderedGraph> randomGraphs = new List<VertexOrderedGraph>();
		
		for (int i = 0; i < numberOfRandomGraphsPerTest; i++)
		{
			randomGraphs.Add(VertexOrderedGraph.RandomGraph(numberOfVertices, edgeProbability));
		}
		
		//have the random graphs.
		VertexOrderedGraph[] orderedAscending = randomGraphs.Select(x => x.ReorderByAscendingDegree()).ToArray();
		VertexOrderedGraph[] orderedDescending = randomGraphs.Select(x => x.ReorderByDescendingDegree()).ToArray();
		VertexOrderedGraph[] orderedMinimumDegreeAmongSubgraph = randomGraphs.Select(x => x.ReorderByMinimalAmongSubgraphs()).ToArray();
		VertexOrderedGraph[] orderedRandomly = randomGraphs.Select(x => x.ReorderRandomly()).ToArray();
		
		//do the tests
		
		List<double> secondsToComputeAscending = new List<double>();
		List<double> secondsToComputeDescending = new List<double>();
		List<double> secondsToComputeMinimumDegreeAmongSubgraph = new List<double>();
		List<double> secondsToComputeRandomly = new List<double>();
		
		for (int i = 0; i < randomGraphs.Count; i++)
		{
			double seconds;
			DateTime startTime, endTime;
			
			//ascend
			startTime = DateTime.Now;
			orderedAscending[i].GreedyColouring();
			endTime = DateTime.Now;
			seconds = (endTime - startTime).TotalSeconds;
			secondsToComputeAscending.Add(seconds);
			
			
			//descend
			startTime = DateTime.Now;
			orderedDescending[i].GreedyColouring();
			endTime = DateTime.Now;
			seconds = (endTime - startTime).TotalSeconds;
			secondsToComputeDescending.Add(seconds);
			
			//minimal among
			startTime = DateTime.Now;
			orderedMinimumDegreeAmongSubgraph[i].GreedyColouring();
			endTime = DateTime.Now;
			seconds = (endTime - startTime).TotalSeconds;
			secondsToComputeMinimumDegreeAmongSubgraph.Add(seconds);
			
			//random
			startTime = DateTime.Now;
			orderedRandomly[i].GreedyColouring();
			endTime = DateTime.Now;
			seconds = (endTime - startTime).TotalSeconds;
			secondsToComputeRandomly.Add(seconds);
			
			
		}
		double averageSecondsAscending = secondsToComputeAscending.Average();
		double averageSecondsDescending = secondsToComputeDescending.Average();
		double averageSecondsMinimal = secondsToComputeMinimumDegreeAmongSubgraph.Average();
		double averageSecondsRandomly = secondsToComputeRandomly.Average();
		
		Console.WriteLine(numberOfVertices + "\t" + averageSecondsAscending + "\t" + averageSecondsDescending + "\t" + averageSecondsMinimal + "\t" + averageSecondsRandomly);
		
		
	}
	
	Console.WriteLine("Find cliques algorithm - q4");
	
	Console.WriteLine("n\taverageSecondsToCompute");
	
	
	for (int numberOfVertices = 30; numberOfVertices <= 70; numberOfVertices += 5)
	{
		List<VertexOrderedGraph> randomGraphs = new List<VertexOrderedGraph>();
		
		for (int i = 0; i < numberOfRandomGraphsPerTest; i++)
		{
			randomGraphs.Add(VertexOrderedGraph.RandomGraph(numberOfVertices, edgeProbability));
		}
		
		//have the random graphs.
		
		//do the tests
		
		List<double> secondsToCompute = new List<double>();
		
		foreach (VertexOrderedGraph randomGraph in randomGraphs)
		{
			DateTime startTime = DateTime.Now;
			
			randomGraph.FindCliques();
			
			DateTime endTime = DateTime.Now;
			
			double seconds = (endTime - startTime).TotalSeconds;
			
			secondsToCompute.Add(seconds);
		}
		double averageSeconds = secondsToCompute.Average();
		
		Console.WriteLine(numberOfVertices + "\t" + averageSeconds);
		
		
	}
	
	Console.WriteLine("Find I1, I2, ... algorithm - q5");
	
	Console.WriteLine("n\taverageSecondsToCompute");
	
	for (int numberOfVertices = 30; numberOfVertices <= 70; numberOfVertices += 5)
	{
		List<VertexOrderedGraph> randomGraphs = new List<VertexOrderedGraph>();
		
		for (int i = 0; i < numberOfRandomGraphsPerTest; i++)
		{
			randomGraphs.Add(VertexOrderedGraph.RandomGraph(numberOfVertices, edgeProbability));
		}
		
		//have the random graphs.
		
		//do the tests
		
		List<double> secondsToCompute = new List<double>();
		
		foreach (VertexOrderedGraph randomGraph in randomGraphs)
		{
			DateTime startTime = DateTime.Now;
			
			randomGraph.ColourByQuestion5Method();
			
			DateTime endTime = DateTime.Now;
			
			double seconds = (endTime - startTime).TotalSeconds;
			
			secondsToCompute.Add(seconds);
		}
		double averageSeconds = secondsToCompute.Average();
		
		Console.WriteLine(numberOfVertices + "\t" + averageSeconds);
		
		
	}
	
}
void Question5VaryProbabilityTests(int numberOfRandomGraphs, int verticesInRandomGraphs)
{
	Console.WriteLine("p\tGoldUpperBound\tGnewUpperBound\tG7oldUpperBound\tG7newUpperBound");
	for (int pTimes100 = 40; pTimes100 <= 60; pTimes100 += 1)
	{
		double p = (double)pTimes100 / 100; //to avoid weird stuff like 0.1 + 0.2 = 0.30000001 or whatever due to how doubles are stored
		List<VertexOrderedGraph> randomGraphsG = new List<VertexOrderedGraph>();
		List<VertexOrderedGraph> randomGraphsG7 = new List<VertexOrderedGraph>();
		
		for (int i = 0; i < numberOfRandomGraphs; i++)
		{
			randomGraphsG.Add(VertexOrderedGraph.RandomGraph(verticesInRandomGraphs, p));
			randomGraphsG7.Add(VertexOrderedGraph.RandomGraph(verticesInRandomGraphs, p, 7));
		}
		Console.WriteLine();
		Console.Write(p + "\t");
		
		double GoldUpperBound = Question1UpperBoundAverage(randomGraphsG.ToArray());
		
		Console.Write(GoldUpperBound + "\t");
		double GnewUpperBound = Question5UpperBoundAverage(randomGraphsG.ToArray());
		Console.Write(GnewUpperBound + "\t");
		
		double G7oldUpperBound = Question1UpperBoundAverage(randomGraphsG7.ToArray());
		Console.Write(G7oldUpperBound + "\t");
		double G7newUpperBound = Question5UpperBoundAverage(randomGraphsG7.ToArray());
		Console.Write(G7newUpperBound);
		
		//Console.WriteLine(p + "\t" + GoldUpperBound + "\t" + GnewUpperBound + "\t" + G7oldUpperBound + "\t" + G7newUpperBound);
	}
	Console.WriteLine();
}
void Question1TestsWithGraphs(VertexOrderedGraph[] randomGraphs)
{
	VertexOrderedGraph[] orderedAscending = randomGraphs.Select(x => x.ReorderByAscendingDegree()).ToArray();
	VertexOrderedGraph[] orderedDescending = randomGraphs.Select(x => x.ReorderByDescendingDegree()).ToArray();
	VertexOrderedGraph[] orderedMinimumDegreeAmongSubgraph = randomGraphs.Select(x => x.ReorderByMinimalAmongSubgraphs()).ToArray();
	VertexOrderedGraph[] orderedRandomly = randomGraphs.Select(x => x.ReorderRandomly()).ToArray();
	
	
	for (int i = 0; i < randomGraphs.Length; i++)
	{
		Console.WriteLine("Graph " + (i+1) + " is " + randomGraphs[i].ToString());
	}
	
	
	
	for (int i = 0; i < randomGraphs.Length; i++)
	{
		Console.WriteLine((i + 1) + "\t" + orderedAscending[i].GreedyColouringNumberOfColours() + "\t" + orderedDescending[i].GreedyColouringNumberOfColours() + "\t" + orderedMinimumDegreeAmongSubgraph[i].GreedyColouringNumberOfColours() + "\t" + orderedRandomly[i].GreedyColouringNumberOfColours());
	}
}

void Question4TestsWithGraphs(VertexOrderedGraph[] randomGraphs)
{
	VertexOrderedGraph[] orderedAscending = randomGraphs.Select(x => x.ReorderByAscendingDegree()).ToArray();
	VertexOrderedGraph[] orderedDescending = randomGraphs.Select(x => x.ReorderByDescendingDegree()).ToArray();
	VertexOrderedGraph[] orderedMinimumDegreeAmongSubgraph = randomGraphs.Select(x => x.ReorderByMinimalAmongSubgraphs()).ToArray();
	VertexOrderedGraph[] orderedRandomly = randomGraphs.Select(x => x.ReorderRandomly()).ToArray();
	
	for (int i = 0; i < randomGraphs.Length; i++)
	{
		Console.WriteLine("Graph " + (i + 1) + " is " + randomGraphs[i].ToString());
	}
	
	
	Console.WriteLine("num\tupper bound\tlower bound");
	for (int i = 0; i < randomGraphs.Length; i++)
	{
		int upperBound = (new int[] {orderedAscending[i].GreedyColouringNumberOfColours(), orderedDescending[i].GreedyColouringNumberOfColours(), orderedMinimumDegreeAmongSubgraph[i].GreedyColouringNumberOfColours(), orderedRandomly[i].GreedyColouringNumberOfColours() }).Min();
		
		int lowerBound = randomGraphs[i].FindCliques()[0].Length; //clique number
		Console.WriteLine((i + 1) + "\t" + upperBound + "\t" + lowerBound);
	}
	
}

void Question5TestsWithGraphs(VertexOrderedGraph[] randomGraphs)
{
	VertexOrderedGraph[] orderedAscending = randomGraphs.Select(x => x.ReorderByAscendingDegree()).ToArray();
	VertexOrderedGraph[] orderedDescending = randomGraphs.Select(x => x.ReorderByDescendingDegree()).ToArray();
	VertexOrderedGraph[] orderedMinimumDegreeAmongSubgraph = randomGraphs.Select(x => x.ReorderByMinimalAmongSubgraphs()).ToArray();
	VertexOrderedGraph[] orderedRandomly = randomGraphs.Select(x => x.ReorderRandomly()).ToArray();
	
	for (int i = 0; i < randomGraphs.Length; i++)
	{
		Console.WriteLine("Graph " + (i + 1) + " is " + randomGraphs[i].ToString());
	}
	
	
	Console.WriteLine("num\toldUpperBound\tnewUpperBound\tlowerBound");
	for (int i = 0; i < randomGraphs.Length; i++)
	{
		int upperBoundOld = (new int[] { orderedAscending[i].GreedyColouringNumberOfColours(), orderedDescending[i].GreedyColouringNumberOfColours(), orderedMinimumDegreeAmongSubgraph[i].GreedyColouringNumberOfColours(), orderedRandomly[i].GreedyColouringNumberOfColours() }).Min();
		
		int upperBoundNew = randomGraphs[i].ColourByQuestion5Method().Length;
		
		int lowerBound = randomGraphs[i].FindCliques()[0].Length; //clique number
		Console.WriteLine((i + 1) + "\t" + upperBoundOld + "\t" + upperBoundNew + "\t" + lowerBound);
	}
	
}


double Question1UpperBoundAverage(VertexOrderedGraph[] randomGraphs)
{
	VertexOrderedGraph[] orderedAscending = randomGraphs.Select(x => x.ReorderByAscendingDegree()).ToArray();
	VertexOrderedGraph[] orderedDescending = randomGraphs.Select(x => x.ReorderByDescendingDegree()).ToArray();
	VertexOrderedGraph[] orderedMinimumDegreeAmongSubgraph = randomGraphs.Select(x => x.ReorderByMinimalAmongSubgraphs()).ToArray();
	VertexOrderedGraph[] orderedRandomly = randomGraphs.Select(x => x.ReorderRandomly()).ToArray();
	
	int[] upperBounds = new int[randomGraphs.Length];
	for (int i = 0; i < randomGraphs.Length; i++)
	{
		int upperBound = (new int[] { orderedAscending[i].GreedyColouringNumberOfColours(), orderedDescending[i].GreedyColouringNumberOfColours(), orderedMinimumDegreeAmongSubgraph[i].GreedyColouringNumberOfColours(), orderedRandomly[i].GreedyColouringNumberOfColours() }).Min();
		
		upperBounds[i] = upperBound;
	}
	
	int sum = upperBounds.Sum();
	
	return (double)sum / (double)randomGraphs.Length;
}

double Question5UpperBoundAverage(VertexOrderedGraph[] randomGraphs)
{
	int[] upperBounds = randomGraphs.Select(x => x.ColourByQuestion5Method().Length).ToArray();
	
	int sum = upperBounds.Sum();
	
	return (double)sum / (double)randomGraphs.Length;
}
\end{lstlisting}
				
\newpage
\section{Appendix B: Output}
\label{appendix_b_output}
				
\subsection{Question 1 output}
\label{output_question_1}
\lstinputlisting{Program Output/Question1.txt}

\subsection{Question 4 output}
\label{output_question_4}
\lstinputlisting{Program Output/Question4.txt}

\subsection{Question 5 output}
\label{output_question_5}
\lstinputlisting{Program Output/Question5_firstpart.txt}
\lstinputlisting{Program Output/Question5_varyingp.txt}

\subsection{Question 6 output}
\label{output_question_6}
\lstinputlisting{Program Output/Question6.txt}

\end{document}
